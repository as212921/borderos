#!/usr/bin/env python3

import sys
import jinja2
import sqlite3

from vyos.config import Config
from vyos import ConfigError

config_file = r'/etc/powerdns/pdns.conf'

# XXX: pdns recursor doesn't like whitespace near entry separators,
# especially in the semicolon-separated lists of name servers.
# Please be careful if you edit the template.
config_tmpl = """
### Autogenerated by dns_server.py ###

# Non-configurable defaults
daemon=yes
log-common-errors=yes
non-local-bind=yes
query-local-address=0.0.0.0
query-local-address6=::

launch={{ backend | join(", ") }}
{% if "gsqlite3" in backend %}
gsqlite3-database={{ sqlite_database }}
gsqlite3-pragma-synchronous={{ sqlite_sync }}
gsqlite3-pragma-foreign-keys={{ sqlite_foreign_keys }}
gsqlite3-dnsses={{ sqlite_dnssec }}
{% endif %}
{% if "bind" in backend %}
bind-config={{ bind_config }}
bind-check-interval={{ bind_check_interval }}
bind-dnssec-db={{ bind_dnssec_db }}
bind-ignore-broken-records={{ bind_ignore_broken_records }}
{% endif %}

# listen-on
local-address={{ listen_on | join(", ") }}

# performance optimisations
receiver-threads={{ receiver_threads }}
distributor-threads={{ distributor_threads }}
cache-ttl={{ cache_ttl }}

{% if mode == "master" %}
master=true
{% endif %}
{% if mode == "slave" %}
slave=on
slave-cycle-interval={{ slave_cycle_interval }}
allow-unsigned-notify={{ allow_unsigned_notify }}
{% endif %}

"""

migration = """
PRAGMA foreign_keys = 1;

CREATE TABLE domains (
  id                    INTEGER PRIMARY KEY,
  name                  VARCHAR(255) NOT NULL COLLATE NOCASE,
  master                VARCHAR(128) DEFAULT NULL,
  last_check            INTEGER DEFAULT NULL,
  type                  VARCHAR(6) NOT NULL,
  notified_serial       INTEGER DEFAULT NULL,
  account               VARCHAR(40) DEFAULT NULL
);

CREATE UNIQUE INDEX name_index ON domains(name);


CREATE TABLE records (
  id                    INTEGER PRIMARY KEY,
  domain_id             INTEGER DEFAULT NULL,
  name                  VARCHAR(255) DEFAULT NULL,
  type                  VARCHAR(10) DEFAULT NULL,
  content               VARCHAR(65535) DEFAULT NULL,
  ttl                   INTEGER DEFAULT NULL,
  prio                  INTEGER DEFAULT NULL,
  disabled              BOOLEAN DEFAULT 0,
  ordername             VARCHAR(255),
  auth                  BOOL DEFAULT 1,
  FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX records_lookup_idx ON records(name, type);
CREATE INDEX records_lookup_id_idx ON records(domain_id, name, type);
CREATE INDEX records_order_idx ON records(domain_id, ordername);


CREATE TABLE supermasters (
  ip                    VARCHAR(64) NOT NULL,
  nameserver            VARCHAR(255) NOT NULL COLLATE NOCASE,
  account               VARCHAR(40) NOT NULL
);

CREATE UNIQUE INDEX ip_nameserver_pk ON supermasters(ip, nameserver);


CREATE TABLE comments (
  id                    INTEGER PRIMARY KEY,
  domain_id             INTEGER NOT NULL,
  name                  VARCHAR(255) NOT NULL,
  type                  VARCHAR(10) NOT NULL,
  modified_at           INT NOT NULL,
  account               VARCHAR(40) DEFAULT NULL,
  comment               VARCHAR(65535) NOT NULL,
  FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX comments_idx ON comments(domain_id, name, type);
CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);


CREATE TABLE domainmetadata (
 id                     INTEGER PRIMARY KEY,
 domain_id              INT NOT NULL,
 kind                   VARCHAR(32) COLLATE NOCASE,
 content                TEXT,
 FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX domainmetaidindex ON domainmetadata(domain_id);


CREATE TABLE cryptokeys (
 id                     INTEGER PRIMARY KEY,
 domain_id              INT NOT NULL,
 flags                  INT NOT NULL,
 active                 BOOL,
 published              BOOL DEFAULT 1,
 content                TEXT,
 FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX domainidindex ON cryptokeys(domain_id);


CREATE TABLE tsigkeys (
 id                     INTEGER PRIMARY KEY,
 name                   VARCHAR(255) COLLATE NOCASE,
 algorithm              VARCHAR(50) COLLATE NOCASE,
 secret                 VARCHAR(255)
);

CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);

"""

default_config_data = {
    'mode': 'standalone',
    'listen_on': [],
    'backend': 'gsqlite3',
    'sqlite_database': '',
    'sqlite_sync': 2,
    'sqlite_foreign_keys': 'yes',
    'sqlite_dnssec': 'yes',
    'bind_config': '',
    'bind_check_interval': 0,
    'bind_dnssec_db': '',
    'bind_ignore_broken_records': 'no',
    'receiver_threads': 1,
    'distributor_threads': 3,
    'cache_ttl': 60,
    'slave_cycle_interval': 60,
    'allow_unsigned_notify': 'yes',
}

def get_backend_config(dns, backend):
    conf = Config()

    dns['backend'] = dns['backend'] + backend
    conf.set_level('service dns server backend {0}'.format(backend))

    if backend == "gsqlite3":
        if conf.exists('database'):
            dns['sqlite_database'] = conf.return_values('database')

        if conf.exists('sync'):
            dns['sqlite_sync'] = conf.return_values('sync')

        if conf.exists('ignore-foreign-keys'):
            dns['sqlite_foreign_keys'] = 'no'

        if conf.exists('dnssec'):
            dns['sqlite_dnssec'] = conf.return_values('dnssec')
    elif backend == "bind":
        if conf.exists('config'):
            dns['bind_config'] = conf.return_values('config')

        if conf.exists('check-interval'):
            dns['bind_check_interval'] = conf.return_values('check-interval')

        if conf.exists('dnssec-db'):
            dns['bind_dnssec_db'] = conf.return_values('dnssec-db')

        if conf.exists('ignore-broken-records'):
            dns['bind_ignore_broken_records'] =\
                conf.return_values('ignore-broken-records')

    return dns

def get_config():
    dns = default_config_data
    conf = Config()

    if not conf.exists('service dns server'):
        return None

    conf.set_level('service dns server')

    if conf.exists('mode'):
        dns['mode'] = conf.return_values('mode')

    if conf.exists('listen-address'):
        dns['listen_on'] = bracketize_ipv6_addrs(
            conf.return_values('listen-address')
        )

    for backend in conf.list_nodes('backend'):
        dns = get_backend_config(dns, backend)

    return dns

def bracketize_ipv6_addrs(addrs):
    """Wraps each IPv6 addr in addrs in [], leaving IPv4 addrs untouched."""
    return ['[{0}]'.format(a) if a.count(':') > 1 else a for a in addrs]

def verify(dns):
    # bail out early - looks like removal from running config
    if dns is None:
        return None

    for backend in dns['backend']:
        if not backend in {'bind', 'gsqlite3'}:
            raise ConfigError('ERROR: DNS server backend not supported')

    if dns['backend'] == 'gsqlite3':
        if not dns['sqlite_database']:
            raise ConfigError('ERROR: DNS server backend database is required')

    return None

def generate(dns):
    # bail out early - looks like removal from running config
    if dns is None:
        return None

    tmpl = jinja2.Template(config_tmpl, trim_blocks=True)
    config_text = tmpl.render(dns)
    with open(config_file, 'w') as f:
        f.write(config_text)
    return None

def apply(dns):
    if dns is None:
        # DNS server is removed in the commit
        os.system("systemctl stop pdns-server")
        if os.path.isfile(config_file):
            os.unlink(config_file)
    else:
        if "gsqlite3" in dns['backend']:
            conn = sqlite3.connect(dns['sqlite_database'])
            cursor = conn.cursor()
            cursor.execute("""
                SELECT count(*) FROM sqlite_master
                WHERE type='table' AND name='table_name';
            """)
            if not cursor.fetchone():
                cursor.executescript(migration)
                conn.commit()
            conn.close()

        os.system("systemctl restart pdns-server")

    return None

try:
    c = get_config()
    verify(c)
    generate(c)
    apply(c)
except ConfigError as e:
    print(e)
    sys.exit(1)
